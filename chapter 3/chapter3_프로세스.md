# 3.1 프로세스 개념 

`프로세스`란 실행 중인 프로그램을 말한다.

프로세스의 현재 활동 상태는 `프로그램 카운터` 값과 `프로세서 레지스터`로 나타낸다.

```
// 프로세스 메모리 배치

* 스택 : 함수를 호출할 때 임시로 데이터를 저장
* 힙 : 프로그램 실행중에 동적으로 할당되는 메모리
* 데이터 : 전역 변수
* 텍스트 : 실행 코드
```

프로세스는 실행되면서 `state`가 변한다.

```
* new
* running
* waiting
* ready
* terminated
```

각 프로세스는 운영체제에서 `프로세스 제어 블록(process control block, PCB)`에 의해 표현된다.

a process is a program that performs `a single thread` of excution.

현대의 운영체제는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 `스레드`를  가질 수 있도록 허용한다.


* * *

# 3.2 프로세스 스케줄링

`multiprogramming`의 목적은 CPU를 최대한 이용하기 위해 항상 어떤 프로세스가 실행되도록 하기 위함이다.

`time sharing`의 목적은 각 프로그램이 실행되는 동안 user가 각각의 프로그램과 상호작용 할 수 있도록 프로세스들 사이에서 CPU코어를 자주 교체하기 위함이다.

`프로세서 스케줄러`는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다.

각 CPU 코어는 한 번에 하나의 프로세스를 실행할 수 있다.

프로세스가 시스템에 들어가면 `ready queue`에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 기다린다.

I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 `wait queue`에 삽입된다.

`CPU 스케줄러`의 역할은 ready queue에 있는 프로세스 중에서 하나를 선택하여 CPU 코어를 할당하는 것이다.

프로세스의 `context`는 PCB에 의해 표현된다.

interrupt가 발생하면, 시스템은 실행중인 프로세스의 현재 context를 저장하고, 나중에 다시 실행될 때 그 context를 복구한다.

CPU 코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요한데, 이를 `context switch`라고 한다.

* * *

# 3.3 프로세스에 대한 연산

실행되는 동안 프로세스는 여러 개의 새로운 프로세스들을 생성 할 수 있다.

생성하는 프로세스를 `부모 프로세스`라고 하고 새로운 프로세스를 `자식 프로세스`라고 한다.

운영체제는 `프로세스 식별자(pid)`를 사용하여 프로세스를 구분하는데 보통 정수 값이다.

```
Two possibilities for execution.
1. 부모와 자식이 같이 실행
2. 부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다림

Two possibilites of address space
1. 자식은 부모의 복사본
2. 자식은 새로운 프로그램
```

`UNIX`에서 각 프로세스는 `fork()`로 생성된다. 새로운 프로세스는 원래 프로세스의 주소 공간의 복사본으로 구성된다.

자식 프로세스의 `fork()`의 return value는 0이지만, 자식의 0이 아닌 프로세스 식별자는 부모로 반환된다.

`fork()` 시스템 콜 다음에 두 프로세스 중 한 프로세스가 `exec()` 시스템 콜을 사용하여 자신의 메모리 공간을 새로운 프로그램으로 교체한다.

부모는 `wait()` 시스템 콜로 자식 프로세스가 끝나기를 기다린다.

자식 프로세스가 끝나면, 부모 프로세스는 wait() 호출로부터 재개하여, exit() 시스템 콜을 사용하여 끝낸다.

자식 프로세스가 `exec()`를 호출하지 않고 부모 프로세스의 복사본을 계속 실행하는 것을 막을 방법은 없다.

프로세스가 `exit()` 시스템 콜을 사용하여 운영체제에 지신의 삭제를 요청하면 종료한다.

이 시점에서, 프로세스는 자신을 기다리고 있는 부모 프로세스에(wait 시스템 콜을 통해) 상태 값을 반환할 수 있다.

부모는 아래와 같은 이유들로 자식 중 하나의 실행을 종료할 수 있다.

```
1. 자식이 자신에게 할당된 자원을 초과하여 사용할 때
2. 자식에게 할당된 태스크가 더 이상 필요 없을 때
3. 부모가 exit 하는데, 운영체제가 부모가 exit한 후에 자식이 실행을 계속 하는 것을 허용하지 않는 경우
```

`zombie process` : a process that has terminated, but whose parent has not yet called wait()

`orphan process` : a process that has a parent process who did not invoke wait() and instead terminated.

* * *

# 3.4 프로세스 간 통신

`cooperating processes`는 데이터를 서로 교환할 수있는 `IPC(interprocess communication)` 기법이 필요하다.

`IPC`에는 기본적으로 `shared memory`와 `message passing`의 두 가지 모델이 있다.

* * *

# 3.5 공유 메모리 시스템에서의 프로세스 간 통신

* `shared memory`

`공유 메모리 영역`은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치한다.

이 공유 메모리 세그먼트를 이용하여 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가해야 한다.

일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 금지하지만, 공유 메모리는 둘 이상의 프로세스가 접근할 수 있다.

데이터의 형식과 위치는 프로세스에 의해 결정되며 운영체제가 관리하지 않는다.

* `producer-consumer problem`

`생산자 프로세스(producer process)`는 정보를 생산하고, `소비자 프로세스(consumer process)`는 정보를 소비한다.

일반적으로 서버를 생산자로 클라이언트를 소비자로 생각할 수 있다.

`생산자 - 소비자`문제의 해결책 중 하나는 공유 메모리를 사용하는 것이다.

* `buffer`

생산자와 소비자 프로세스가 동시에 실행되도록 하려면, 생산자가 정보를 채워 넣고 소비자가 소모할 수 있는 항목들의 `버퍼`가 반드시 사용 가능해야 한다.

이 버퍼는 생산자와 소비자가 공유하는 메모리 영역에 존재하게 된다.

버퍼에는 두 가지 유형이 있다.

`무한 버퍼(unbounede buffer)`의 경우 버퍼의 크기에 한계가 없다. 버퍼가 비어있으면 소비자는 대기해야 하지만, 생산자는 항상 새로운 항목을 생산가능하다.

`유한 버퍼(bounded buffer)`의 경우 버퍼의 크기가 고정되어 있다고 가정한다. 이 경우 버퍼가 비어 있으면 소비자가 대기해야 하고, 모든 버퍼가 채워져 있으면 생산자가 대기한다. 

* * *

# 3.6 메세지 전달 시스템에서의 프로세스간 통신

