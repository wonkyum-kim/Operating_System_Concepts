# 6.1 배경

* **data inconsistency**

생산자와 소비자 코드는 개별적으로 올바르게 동작할지라도, 병행적(concurrently)로 실행하면 올바르게 동작하지 않는다.

왜냐하면 기계어 수준에서 볼 때 중간에 문맥교환이 일어나면 다른 결과가 나오게 되기 때문이다.

* **race condition**

몇개의 프로세스가 같은 데이터를 병행적으로 접근하거나 조작한다면, 실행 결과는 접근이 발생한 순서에 따라 다르다.

`경쟁 상황`을 방지하기 위해서 어느 시점에서 하나의 프로세스만이 공유 데이터를 조작하도록 해야한다.

* * *

# 6.2 임계구역 문제(the critical section problem)

* **critical section**

n개의 프로세스가 있는 시스템에서 각 프로세스는 `임계 구역`이라고 부르는 코드를 포함하고 있고,

그 안에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고 갱신할 수 있다.

이 시스템에서는 한 프로세스가 자신의 임계구역에서 수행하는 동안에는 다른 프로세스들은 그 구역에 들어갈 수 없다.

각 프로세스는 자신의 임계구역으로 진입하려면 진입허가를 요청해야 하는데, 이러한 부분을 `진입 구역(entry section)`이라고 한다.

임계 구역 뒤에는 `퇴출 구역(exit section)`이 따라온다.

그리고 코드의 나머지 부분을 `나머지 구역(remainder section)`이라고 한다.

```
// 임계 구역 문제 해결을 위한 요구조건

1. 상호 배제(mutual exclusion) : 한 프로세스가 자기의 임계 구역에서 실행된다면, 다른 프로세스들은 그들 자신의 임계 구역에서 실행될 수 없다.
2. 진행(progress) : 자신의 임계 구역에서 실행되는 프로세스가 없으면, 나머지 구역에서 실행중이지 않은 프로세스들 중에서만 그 임계 구역으로 진입할 수 있는지 결정할 수 있다.
3. 한정된 대기(bounded waiting) : 프로세스가 임계 구역에 진입하려는 요청을 한 뒤에, 다른 프로세스들이 임계 구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다.
```

* * *

# 6.3 Peterson의 해결안

현대 컴퓨터 구조가 `load`와 `store`와 같은 기본적인 기계어를 수행하는 방식 때문에 올바르게 실행된다고 보장할 수 없다.

하지만 `Peterson's solution`은 알고리즘적으로 임계 구역 문제를 해결하는 좋은 방법을 제시한다.

```
int turn;
bool flag[2];

while (true) {
  flag[i] = true;
  turn j;
  
  while (flag[j] && turn == j) {  // j가 임계영역에서 실행되고 있는지 체크한다.
  };
  
  /* critical section */
  
  flag[i] = false;
  
  /* remainder section */
}
```
